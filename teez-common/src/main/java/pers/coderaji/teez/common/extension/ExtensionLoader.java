package pers.coderaji.teez.common.extension;import pers.coderaji.teez.common.Constants;import pers.coderaji.teez.common.utl.Assert;import pers.coderaji.teez.common.utl.ObjectUtil;import java.io.*;import java.lang.reflect.Method;import java.lang.reflect.Modifier;import java.net.URL;import java.nio.charset.StandardCharsets;import java.util.*;import java.util.concurrent.ConcurrentHashMap;import java.util.stream.Collectors;/** * @author aji * @description 扩展加载器 * @date 2024/7/24 14:44 */public class ExtensionLoader<T> {    private static final ConcurrentHashMap<Class<?>, ExtensionLoader<?>> EXTENSION_LOADERS = new ConcurrentHashMap<>();    /**     * 存放type实现类路径     */    private static final String TEEZ = "META-INF/teez/";    /**     * 被@SPI注解标记的接口     *     * @see pers.coderaji.teez.common.extension.SPI     */    private final Class<T> type;    /**     * 扩建工厂     */    private final ExtensionFactory extensionFactory;    /**     * type接口实现类缓存     */    private final ConcurrentHashMap<String, Object> cachedInstances = new ConcurrentHashMap<>();    /**     * 自适应实例缓存     */    private Object cachedAdaptiveInstance = null;    private ExtensionLoader(Class<T> type) {        this.type = type;        this.extensionFactory = Objects.equals(type, ExtensionFactory.class) ? null : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension();    }    @SuppressWarnings("unchecked")    public static <T> ExtensionLoader<T> getExtensionLoader(Class<T> type) {        //1.type必须是一个被@SPI标记的接口        Assert.nonNull(type,"type is null");        //2.缓存中不存在当前加载器对应的        if (!EXTENSION_LOADERS.containsKey(type)) {            Assert.nonFalse(type.isInterface(),type + " is not an interface");            Assert.nonFalse(type.isAnnotationPresent(SPI.class),"SPI is not present on this " + type);            EXTENSION_LOADERS.putIfAbsent(type, new ExtensionLoader<>(type));        }        return (ExtensionLoader<T>) EXTENSION_LOADERS.get(type);    }    @SuppressWarnings("unchecked")    public T getDefaultExtension() {        SPI spi = type.getAnnotation(SPI.class);        String value = spi.value();        T instance = (T) cachedInstances.get(value);        if (ObjectUtil.isEmpty(cachedInstances)) {            loadImplements();            instance = (T) cachedInstances.put(value, injectExtension((T) cachedInstances.get(value)));        }        return instance;    }    @SuppressWarnings("unchecked")    public T getAdaptiveExtension() {        if (Objects.isNull(cachedAdaptiveInstance)) {            loadImplements();            injectExtension((T) cachedAdaptiveInstance);        }        return (T) cachedAdaptiveInstance;    }    @SuppressWarnings("unchecked")    public T getExtension(String name) {        T instance = (T) cachedInstances.get(name);        if (ObjectUtil.isEmpty(cachedInstances)) {            loadImplements();            instance = (T) cachedInstances.put(name, injectExtension((T) cachedInstances.get(name)));        }        return instance;    }    public Set<String> getSupportedExtensions() {        if (ObjectUtil.isEmpty(cachedInstances)) {            loadImplements();        }        return new HashSet<>(cachedInstances.keySet());    }    private void loadImplements() {        //1.获取文件名，与接口全路径名一致        String interfaceName = type.getName();        //2.获取文件相对路径        String relativePath = TEEZ + interfaceName;        //3.获取资源        Enumeration<URL> resources = getResources(relativePath);        if (Objects.nonNull(resources)) {            while (resources.hasMoreElements()) {                URL url = resources.nextElement();                try {//4.读取文件内容                    BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream(), StandardCharsets.UTF_8));                    String line = null;                    int num = 1;                    //5.按行读取                    while (Objects.nonNull(line = reader.readLine())) {                        //6.文件按k=v形式存数据                        Assert.nonFalse(line.contains(Constants.EQUAL),num + " line of the " + interfaceName + " is not a key = value pair");                        String[] split = line.split(Constants.EQUAL);                        Assert.nonFalse(Objects.equals(split.length, 2),num + " line of the " + interfaceName + " is not a key = value pair");                        String key = split[0];                        Class<?> aClass = Class.forName(split[1], true, ExtensionLoader.class.getClassLoader());                        Object value = aClass.newInstance();                        //7.一个接口只能有一个被@Adaptive标记的实现类                        if (aClass.isAnnotationPresent(Adaptive.class)) {                            Assert.nonNull(cachedAdaptiveInstance,"more than 1 adaptive class found");                            cachedAdaptiveInstance = value;                        }                        //8.实现类保存到缓存                        cachedInstances.putIfAbsent(key, value);                        num++;                    }                } catch (Exception e) {                    throw new RuntimeException(e);                }            }        }    }    private Enumeration<URL> getResources(String relativePath) {        Enumeration<URL> resources;        try {            ClassLoader classLoader = ExtensionLoader.class.getClassLoader();            if (Objects.isNull(classLoader)) {                return ClassLoader.getSystemResources(relativePath);            }            resources = classLoader.getResources(relativePath);        } catch (Exception e) {            throw new RuntimeException(e);        }        return resources;    }    private T injectExtension(T instance) {        if (Objects.nonNull(instance) && Objects.nonNull(extensionFactory)) {            Method[] methods = instance.getClass().getMethods();            for (Method method : methods) {                //1.通过setter注入扩展                if (method.getName().startsWith(Constants.SET)                        && Objects.equals(method.getParameters().length, Constants.PARAM_LENGTH)                        && Modifier.isPublic(method.getModifiers())) {                    //2.获取参数类型                    Class<?> parameterType = method.getParameterTypes()[0];                    try {                        //3.获取字段名                        int index = Constants.SET.length();                        String methodName = method.getName();                        String fieldName = methodName.length() > index ? methodName.substring(index, index + 1).toLowerCase() + methodName.substring(index + 1) : "";                        //4.获取参数值                        Object object = extensionFactory.getExtension(parameterType, fieldName);                        if (Objects.nonNull(object)) {                            //5.通过setter赋值                            method.invoke(instance, object);                        }                    } catch (Exception e) {                        throw new RuntimeException(e);                    }                }            }        }        return instance;    }}